package grayt

type vect4 [4]float64

func (v vect4) dot(u vect4) float64 {
	return v[0]*u[0] + v[1]*u[1] + v[2]*u[2] + v[3]*u[3]
}

func (v vect4) reduce() Vector {
	return Vector{v[0], v[1], v[2]}
}

type matrix4 [4]vect4

func (m matrix4) mulm(n matrix4) matrix4 {
	var c matrix4
	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			for k := 0; k < 4; k++ {
				c[i][j] += m[i][k] * n[k][j]
			}
		}
	}
	return c
}

func (m matrix4) mulv(v vect4) vect4 {
	return vect4{
		m[0].dot(v),
		m[1].dot(v),
		m[2].dot(v),
		m[3].dot(v),
	}
}

func (m matrix4) inv() (matrix4, bool) {
	var r matrix4

	// This is not any nicer as loops... Don't attempt to refactor this.

	r[0][0] = m[1][1]*m[2][2]*m[3][3] -
		m[1][1]*m[2][3]*m[3][2] -
		m[2][1]*m[1][2]*m[3][3] +
		m[2][1]*m[1][3]*m[3][2] +
		m[3][1]*m[1][2]*m[2][3] -
		m[3][1]*m[1][3]*m[2][2]

	r[1][0] = -m[1][0]*m[2][2]*m[3][3] +
		m[1][0]*m[2][3]*m[3][2] +
		m[2][0]*m[1][2]*m[3][3] -
		m[2][0]*m[1][3]*m[3][2] -
		m[3][0]*m[1][2]*m[2][3] +
		m[3][0]*m[1][3]*m[2][2]

	r[2][0] = m[1][0]*m[2][1]*m[3][3] -
		m[1][0]*m[2][3]*m[3][1] -
		m[2][0]*m[1][1]*m[3][3] +
		m[2][0]*m[1][3]*m[3][1] +
		m[3][0]*m[1][1]*m[2][3] -
		m[3][0]*m[1][3]*m[2][1]

	r[3][0] = -m[1][0]*m[2][1]*m[3][2] +
		m[1][0]*m[2][2]*m[3][1] +
		m[2][0]*m[1][1]*m[3][2] -
		m[2][0]*m[1][2]*m[3][1] -
		m[3][0]*m[1][1]*m[2][2] +
		m[3][0]*m[1][2]*m[2][1]

	r[0][1] = -m[0][1]*m[2][2]*m[3][3] +
		m[0][1]*m[2][3]*m[3][2] +
		m[2][1]*m[0][2]*m[3][3] -
		m[2][1]*m[0][3]*m[3][2] -
		m[3][1]*m[0][2]*m[2][3] +
		m[3][1]*m[0][3]*m[2][2]

	r[1][1] = m[0][0]*m[2][2]*m[3][3] -
		m[0][0]*m[2][3]*m[3][2] -
		m[2][0]*m[0][2]*m[3][3] +
		m[2][0]*m[0][3]*m[3][2] +
		m[3][0]*m[0][2]*m[2][3] -
		m[3][0]*m[0][3]*m[2][2]

	r[2][1] = -m[0][0]*m[2][1]*m[3][3] +
		m[0][0]*m[2][3]*m[3][1] +
		m[2][0]*m[0][1]*m[3][3] -
		m[2][0]*m[0][3]*m[3][1] -
		m[3][0]*m[0][1]*m[2][3] +
		m[3][0]*m[0][3]*m[2][1]

	r[3][1] = m[0][0]*m[2][1]*m[3][2] -
		m[0][0]*m[2][2]*m[3][1] -
		m[2][0]*m[0][1]*m[3][2] +
		m[2][0]*m[0][2]*m[3][1] +
		m[3][0]*m[0][1]*m[2][2] -
		m[3][0]*m[0][2]*m[2][1]

	r[0][2] = m[0][1]*m[1][2]*m[3][3] -
		m[0][1]*m[1][3]*m[3][2] -
		m[1][1]*m[0][2]*m[3][3] +
		m[1][1]*m[0][3]*m[3][2] +
		m[3][1]*m[0][2]*m[1][3] -
		m[3][1]*m[0][3]*m[1][2]

	r[1][2] = -m[0][0]*m[1][2]*m[3][3] +
		m[0][0]*m[1][3]*m[3][2] +
		m[1][0]*m[0][2]*m[3][3] -
		m[1][0]*m[0][3]*m[3][2] -
		m[3][0]*m[0][2]*m[1][3] +
		m[3][0]*m[0][3]*m[1][2]

	r[2][2] = m[0][0]*m[1][1]*m[3][3] -
		m[0][0]*m[1][3]*m[3][1] -
		m[1][0]*m[0][1]*m[3][3] +
		m[1][0]*m[0][3]*m[3][1] +
		m[3][0]*m[0][1]*m[1][3] -
		m[3][0]*m[0][3]*m[1][1]

	r[3][2] = -m[0][0]*m[1][1]*m[3][2] +
		m[0][0]*m[1][2]*m[3][1] +
		m[1][0]*m[0][1]*m[3][2] -
		m[1][0]*m[0][2]*m[3][1] -
		m[3][0]*m[0][1]*m[1][2] +
		m[3][0]*m[0][2]*m[1][1]

	r[0][3] = -m[0][1]*m[1][2]*m[2][3] +
		m[0][1]*m[1][3]*m[2][2] +
		m[1][1]*m[0][2]*m[2][3] -
		m[1][1]*m[0][3]*m[2][2] -
		m[2][1]*m[0][2]*m[1][3] +
		m[2][1]*m[0][3]*m[1][2]

	r[1][3] = m[0][0]*m[1][2]*m[2][3] -
		m[0][0]*m[1][3]*m[2][2] -
		m[1][0]*m[0][2]*m[2][3] +
		m[1][0]*m[0][3]*m[2][2] +
		m[2][0]*m[0][2]*m[1][3] -
		m[2][0]*m[0][3]*m[1][2]

	r[2][3] = -m[0][0]*m[1][1]*m[2][3] +
		m[0][0]*m[1][3]*m[2][1] +
		m[1][0]*m[0][1]*m[2][3] -
		m[1][0]*m[0][3]*m[2][1] -
		m[2][0]*m[0][1]*m[1][3] +
		m[2][0]*m[0][3]*m[1][1]

	r[3][3] = m[0][0]*m[1][1]*m[2][2] -
		m[0][0]*m[1][2]*m[2][1] -
		m[1][0]*m[0][1]*m[2][2] +
		m[1][0]*m[0][2]*m[2][1] +
		m[2][0]*m[0][1]*m[1][2] -
		m[2][0]*m[0][2]*m[1][1]

	det := m[0][0]*r[0][0] + m[0][1]*r[1][0] + m[0][2]*r[2][0] + m[0][3]*r[3][0]

	if det == 0 {
		return r, false
	}

	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			r[i][j] /= det
		}
	}
	return r, true
}

func translation(x, y, z float64) matrix4 {
	var m matrix4
	for i := 0; i < 4; i++ {
		m[i][i] = 1.0
	}
	m[0][3] = x
	m[1][3] = y
	m[2][3] = z
	return m
}
